
# Challenges
We have work to do! I'm going to simply small problems for you guys so that you can fill in the gaps and make this game work. I'll give each of you tasks, and over the next couple of days or so, we'll hammer them out and finish this game. 

#### Ask Dan for help üëä

## Brady

### ‚úÖ Our Clouds keep disappearing üôÄ
Clayton found an [issue](https://github.com/GM-Coding-Club/birdhouse/issues/2), and it looks like our clouds are running away! Let me quick explain how the clouds work, and what might be going wrong, and how you can fix the issue. At the start of our game, we generate 200 different clouds, giving them a location somewhere on or off the screen (x and y coordinates), a sprite, and a direction as to where they travel. Each game tick, we move the clouds 1 pixel based on their direction: so we add or remove 1 to the current cloud x coordinate. Our world is a grid, and every cloud always has an x and y coordinate to articulate where it is in that space. Since our clouds are drifting, they eventually go off screen. That's a problem! One solution for this problem is that we don't spawn clouds at the start of the game, but rather create new clouds on a timer (every 20 seconds maybe). When those clouds eventually move off screen, we'll delete them, and forget about them. Because we're creating a new cloud every 20 seconds or so, the clouds we delete will be replaced by new clouds. That's a lot of steps, though, and would require us to remember the last time that we spawned a cloud, to make events to know when clouds go off screen, to track how high a user has built their birdhouse tower so we can spawn clouds at the appropriate height, and more. A lot of moving pieces! But I have a simpler solution ‚Äî and it's broken! Rather than spawning clouds, we generate an appropriate number in the beginning (200), with y's that will be useful in the future, and x's that will allow us to have a constant flow of clouds. So we spawn clouds all over a giant grid that's bigger than the size of our screen, and just wait until they move into the screen view, whether its because a user is scrolling, or the clouds are moving. And when those clouds reach a barrier, we flip them, so we reuse the same clouds. A lot simpler than spawning and deleting clouds, right? This work takes place in the `reducers/clouds.js`. The `initialState` takes an array of 200 randomly generated clouds from the `randomClouds()` method. Every `GAME_TICK` event, we call the `gameTick()` method, which uses `moveClouds()` and `cloudAssign()` to return our new array of adjusted clouds. The magic happens in `cloudAssign()`: that's where we actually change the x coordinate, and flip directions. 

## Clayton

### üõë Drag and Drop Building

We have a basic store infrastructure now! But our button's are paperweights. Hayden will be working on populating the store with useful items, but in the meantime, you'll need to figure out how to use them. Items should be dragged from the top menu into the grid, and placed when applicable. If the item can be placed, it will glow green, if it can't it will glow red. Some items like bird feeders are simple: they can be hung off of some pipes. They can't be touching the ground, though! Since we are using vertical real estate, our bird feeder towers will get crazy, and go in many directions to maximize space. This means there are a bunch of different sprites for pipes that can be utilized. When you connect a pipe, if the position is valid, the sprites surrouding that pipe should change approprietly. So there are really two parts to the problem: 1) you need to build the UI elements and controls for dragging hovering items 2) you need to develop an infrastructure that understands valid placements within the grid. It's fairly simply to store items within the state, and to update them accoridnly. This one will be fun üòÖ

## Hayden

### üõë Birds ü¶â

We need to implement our birds! In the `img/` folder, you will now see 24 different bird sprites. It's up to you to work with Brady to identify which of these best suit our list of 7 birds. Then we need to finish developing our `models/bird.js` file. Models are a way to programmatically represent information in a standardized format ‚Äî we recreate all of our information and logic in software form, and use these newly created tools later in our program. Our cloud model `models/cloud.js` is already complete and will offer a lot of assitance. All you need to do is finish our `Bird()` method, which returns a literal representation (an object) with paramaters (keys) about a newly generated, flying bird. This method will be called from our bird spawner, which is your next job. It's a simple task üëç

### üõë Bird Spawner

Now that we can create the basic state of a bird given its type and coordinates, we need to figure out when to do that. We need to create a spawner that randomly creates birds, given their rarity, and if there is anything on the map that would entice the bird to appear. Unlike clouds, we can't rely on of our game tick to accomplish this. In `reducers/birds.js`, you'll see a `gameTick()` method that moves birds. In this reducer, we are limited to the scope of birds ‚Äî so we can move birds, create birds, and anything else that is just reliant on the state of birds. In `actions/index.js` you'll see a list of these actions. You should first implement these actions, and then implement their reducers, just like you've seen in `reducers/clouds.js`. These are dumb actions, because they just do exactly what you tell them to do: they don't consider the current state of the board, or the rules in which birds can be spawned. These actions will be called by a smarter logic system. Let me explain how that works! Our game tick is kind of a hack: because actions are available to every reducer, we can use the `GAME_TICK` action in every reducer. But, that's an issue when we need to do something smart on every game tick; we don't know where bird houses are on the board in the birds reducer, so we can't spawn birds there. Instead, we have to look higher up in the program, and understand how the game tick works. In our highest react component `App.js` we have a timer that runs 24 times per second, and dispatches a smart action called `gameTick()`. That smart action comes from `logic/index.js`. In the `gameTick()` smart method, we dispatch the dumb `GAME_TICK` action, which tells all of our reducers that there was a game tick. Then we can write code or dispatch other actions. You'll need to work with Clayton to understand what the current state of our board (`getState().board`) means, so that you know when and where to spawn a bird with your `spawnBird()` action.

## Kyle 

### üõë Bird Spotter

Every time we encounter a new bird, we should show an alert to teach the students about the bird that just appeared. You should start by looking over how our Guide (the top-right button) works. There are two parts: the state part, and the interface part. When we tap the button, we are telling the state that the guide should be visible, and then we use the interface to display our list of spotted birds and information about them. All of this state information is in `reducers/guide.js`. It's your job to create spotted actions in `actions/index.js` and to use those actions in `reducers/spotted.js` to update the state. When the state updates, the alert will automatically be displayed. It's your job to create the interface for this alert using the the bird information that is passed to it. There are two different pieces to an interface component. The first is the component itself, `components/SpottedModal.js`, and then there is a container for that component, `containers/SpottedModal.js`. The component is kind of dumb: it takes information called props that just tell the component what to do. You can access props in the component like `this.props.nameOfProp`. For example, the visible variable in the state is passed to the component using something called a container. The container takes a component, and adds props to it. Props can be both dispatch functions and state information. State information is added as a prop in `mapStateToProps()` and dispatch functions are added in `mapDispatchToProps()`. It's your job to add a hide dispatch function (like in the guide) that lets the user hide the alert. Otherwise it's stuck forever! You also need to use the props to display an image of the bird (using the type), text that says you spotted the bird, and a description about the bird. Hayden will have information about how the bird information is represented.